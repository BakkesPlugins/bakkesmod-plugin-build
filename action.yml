name: 'BakkesMod Plugin Build Action'
description: 'A composite action to build BakkesMod plugins'
author: 'Bakkesplugins'

inputs:
  build-config:
    description: 'Build configuration (Debug or Release)'
    required: false
    default: 'Release'
  
  bakkesmod-sdk-ref:
    description: 'Git reference for BakkesMod SDK (branch, tag, or commit)'
    required: false
    default: 'master'
  
  vcpkg-ref:
    description: 'Git reference for vcpkg (branch, tag, or commit)'
    required: false
    default: 'master'
  
  retention-days:
    description: 'Number of days to retain build artifacts'
    required: false
    default: '30'

outputs:
  artifact-name:
    description: 'Name of the uploaded artifact (with PDB files)'
    value: ${{ steps.create-archive.outputs.artifact-name }}
  
  zip-path:
    description: 'Path to the created release zip file (with PDB files)'
    value: ${{ steps.create-archive.outputs.zip-path }}
  
  public-artifact-name:
    description: 'Name of the public release artifact (without PDB files)'
    value: ${{ steps.create-public-archive.outputs.public-artifact-name }}
  
  public-zip-path:
    description: 'Path to the public release zip file (without PDB files)'
    value: ${{ steps.create-public-archive.outputs.public-zip-path }}
  
  build-status:
    description: 'Status of the build process'
    value: ${{ steps.msbuild.outputs.status }}
  
  build-exit-code:
    description: 'Exit code from the MSBuild process'
    value: ${{ steps.msbuild.outputs.exit-code }}

runs:
  using: 'composite'
  steps:
    - name: Checkout BakkesMod SDK
      uses: actions/checkout@v4
      with:
        repository: bakkesmodorg/BakkesModSDK
        path: bakkesmod\bakkesmodsdk
        ref: ${{ inputs.bakkesmod-sdk-ref }}

    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v2

    - name: Find solution file
      id: find-sln
      shell: pwsh
      run: |
        $sln = Get-ChildItem -Path $env:GITHUB_WORKSPACE -Filter *.sln -Recurse | Select-Object -First 1
        if ($null -eq $sln) { Write-Error 'No .sln file found!'; exit 1 }
        Write-Host "sln path: $($sln.FullName)"
        echo "SOLUTION_PATH=$($sln.FullName)" | Out-File -FilePath $env:GITHUB_ENV -Append
        echo "SOLUTION_DIR=$($sln.DirectoryName)" | Out-File -FilePath $env:GITHUB_ENV -Append

    - name: Check for vcpkg manifest
      id: vcpkg-check
      shell: pwsh
      run: |
        $manifestPath = Join-Path $env:SOLUTION_DIR "vcpkg.json"
        $manifest = Test-Path $manifestPath
        Write-Host "Checking for vcpkg manifest at: $manifestPath"
        Write-Host "vcpkg manifest present: $manifest"
        echo "vcpkg_manifest=$manifest" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

    - name: Checkout vcpkg
      if: steps.vcpkg-check.outputs.vcpkg_manifest == 'True'
      uses: actions/checkout@v4
      with:
        repository: microsoft/vcpkg
        path: vcpkg
        ref: ${{ inputs.vcpkg-ref }}

    - name: Bootstrap vcpkg
      if: steps.vcpkg-check.outputs.vcpkg_manifest == 'True'
      shell: pwsh
      run: |
        .\vcpkg\bootstrap-vcpkg.bat

    - name: Integrate vcpkg
      if: steps.vcpkg-check.outputs.vcpkg_manifest == 'True'
      shell: pwsh
      run: |
        .\vcpkg\vcpkg.exe integrate install

    - name: Build with MSBuild
      id: msbuild
      shell: pwsh
      run: |
        $errorsFile = "$env:RUNNER_TEMP\msbuild-errors.txt"

        Write-Host "::group::MSBuild Output"
        # Use MSBuild's built-in file logger to capture errors only
        # Force OutDir to ensure consistent artifact location regardless of project settings
        # Use the resolved SOLUTION_DIR environment variable instead of $(SolutionDir) which won't be evaluated
        $outDir = "$env:SOLUTION_DIR\plugins\"
        Write-Host "Setting OutDir to: $outDir"
        msbuild /m /v:normal `
          /p:Configuration=${{ inputs.build-config }} `
          /p:BakkesModPath=$env:GITHUB_WORKSPACE\bakkesmod `
          /p:OutDir="$outDir" `
          /p:UseStructuredOutput=false `
          /p:PostBuildEventUseInBuild=false `
          /fl /flp:"logfile=$errorsFile;errorsonly" `
          $env:SOLUTION_PATH
        $exitCode = $LASTEXITCODE
        Write-Host "::endgroup::"

        echo "exit-code=$exitCode" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

        if ($exitCode -ne 0) {
          echo "status=failed" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

          # Check if errors file exists and has content
          if (Test-Path $errorsFile) {
            # ✅ Send multi-line errors as a GitHub output
            echo "errors<<EOF" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            Get-Content $errorsFile | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            echo "EOF" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

            # ✅ Write errors to the summary markdown file
            Add-Content $env:GITHUB_STEP_SUMMARY "### ❌ Build failed"
            Add-Content $env:GITHUB_STEP_SUMMARY ""
            Add-Content $env:GITHUB_STEP_SUMMARY "#### MSBuild errors:"
            Add-Content $env:GITHUB_STEP_SUMMARY ""
            Add-Content $env:GITHUB_STEP_SUMMARY '```text'
            Get-Content $errorsFile | Add-Content $env:GITHUB_STEP_SUMMARY
            Add-Content $env:GITHUB_STEP_SUMMARY '```'

            # Also show in log output
            Write-Host "::error::Build failed. Errors:"
            Get-Content $errorsFile | ForEach-Object { Write-Host $_ }
          } else {
            Write-Host "::error::Build failed but no errors were captured in the log file"
          }

          exit $exitCode
        }

        echo "status=success" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        Write-Host "::notice::Build completed successfully"
        Add-Content $env:GITHUB_STEP_SUMMARY "✅ Build completed successfully"

    - name: Upload error log
      if: failure()
      uses: actions/upload-artifact@v4
      with:
        name: msbuild-errors
        path: ${{ runner.temp }}/msbuild-errors.txt

    - name: Prepare build artifacts
      shell: pwsh
      run: |
        # Create artifacts directories for both versions
        New-Item -ItemType Directory -Force -Path "artifacts/plugins"
        New-Item -ItemType Directory -Force -Path "artifacts-public/plugins"
        
        # Get solution directory from the solution path
        $solutionDir = Split-Path -Parent $env:SOLUTION_PATH
        Write-Host "Solution directory: $solutionDir"
        
        # Look for plugins directory relative to solution
        $pluginsPath = Join-Path $solutionDir "plugins"
        if (Test-Path $pluginsPath) {
          Write-Host "Found plugins directory: $pluginsPath"
          Get-ChildItem -Path $pluginsPath -Include "*.dll", "*.pdb" -Recurse | ForEach-Object {
            Write-Host "Copying: $($_.FullName)"
            # Copy all files (including PDB) to main artifacts
            Copy-Item $_.FullName -Destination "artifacts/plugins" -Force
            
            # Copy only DLL files to public artifacts (excluding PDB)
            if ($_.Extension -eq ".dll") {
              Copy-Item $_.FullName -Destination "artifacts-public/plugins" -Force
            }
          }
        } else {
          Write-Host "No plugins directory found at: $pluginsPath"
        }
        
        # Also check workspace root for backwards compatibility
        if (Test-Path "plugins") {
          Write-Host "Found plugins directory in workspace root"
          Get-ChildItem -Path "plugins" -Include "*.dll", "*.pdb" -Recurse | ForEach-Object {
            # Copy all files (including PDB) to main artifacts
            Copy-Item $_.FullName -Destination "artifacts/plugins" -Force
            
            # Copy only DLL files to public artifacts (excluding PDB)
            if ($_.Extension -eq ".dll") {
              Copy-Item $_.FullName -Destination "artifacts-public/plugins" -Force
            }
          }
        }
        
        # Look for data directory relative to solution and copy to both artifacts
        $dataPath = Join-Path $solutionDir "data"
        if (Test-Path $dataPath) {
          Copy-Item -Path $dataPath -Destination "artifacts/data" -Recurse -Force
          Copy-Item -Path $dataPath -Destination "artifacts-public/data" -Recurse -Force
        } elseif (Test-Path "data") {
          Copy-Item -Path "data" -Destination "artifacts/data" -Recurse -Force
          Copy-Item -Path "data" -Destination "artifacts-public/data" -Recurse -Force
        }
        
        Write-Host "Full artifacts contents (with PDB files):"
        Get-ChildItem -Path "artifacts" -Recurse
        Write-Host ""
        Write-Host "Public artifacts contents (without PDB files):"
        Get-ChildItem -Path "artifacts-public" -Recurse

    - name: Prepare final artifacts structure
      id: create-archive
      shell: pwsh
      run: |
        # Create timestamp for artifact naming
        $timestamp = Get-Date -Format "yyyyMMdd-HHmmss"
        $repoName = "${{ github.event.repository.name }}"
        if ([string]::IsNullOrEmpty($repoName)) {
          $repoName = Split-Path -Leaf $env:GITHUB_WORKSPACE
        }
        
        if (Test-Path "artifacts") {
          echo "artifact-name=$repoName-debug-$timestamp" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          echo "zip-path=artifacts" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          Write-Host "Debug artifacts prepared in: artifacts/ (will be named: $repoName-debug-$timestamp)"
        } else {
          Write-Error "No artifacts found"
          exit 1
        }

    - name: Prepare public artifacts structure
      id: create-public-archive
      shell: pwsh
      run: |
        # Create timestamp for artifact naming
        $timestamp = Get-Date -Format "yyyyMMdd-HHmmss"
        $repoName = "${{ github.event.repository.name }}"
        if ([string]::IsNullOrEmpty($repoName)) {
          $repoName = Split-Path -Leaf $env:GITHUB_WORKSPACE
        }
        
        if (Test-Path "artifacts-public") {
          echo "public-artifact-name=$repoName-public-$timestamp" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          echo "public-zip-path=artifacts-public" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          Write-Host "Public artifacts prepared in: artifacts-public/ (will be named: $repoName-public-$timestamp)"
        } else {
          Write-Error "No public artifacts found"
          exit 1
        }

    - name: Upload debug build artifacts (with PDB files)
      uses: actions/upload-artifact@v4
      with:
        name: ${{ steps.create-archive.outputs.artifact-name }}
        path: ${{ steps.create-archive.outputs.zip-path }}/*
        retention-days: ${{ inputs.retention-days }}

    - name: Upload public release artifacts (without PDB files)
      uses: actions/upload-artifact@v4
      with:
        name: ${{ steps.create-public-archive.outputs.public-artifact-name }}
        path: ${{ steps.create-public-archive.outputs.public-zip-path }}/*
        retention-days: ${{ inputs.retention-days }}

branding:
  icon: 'package'
  color: 'blue'